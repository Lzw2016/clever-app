package org.clever.data.redis.connection.stream;

import org.clever.util.Assert;
import org.clever.util.NumberUtils;
import org.clever.util.ObjectUtils;
import org.clever.util.StringUtils;

import java.util.Objects;

/**
 * 流中单个 {@link Record} 的 ID。
 * 由两部分组成：{@literal <millisecondsTime>-<sequenceNumber>}
 * <p>
 * 作者：lizw <br/>
 * 创建时间：2023/01/24 21:49 <br/>
 *
 * @see <a href="https://redis.io/topics/streams-intro#entry-ids">Redis 文档 - Entriy ID</a>
 */
public class RecordId {
    private static final String GENERATE_ID = "*";
    private static final String DELIMITER = "-";

    /**
     * 服务器自动生成 ID 几乎总是你想要的，所以我们在这里有这个实例来简化计算
     */
    private static final RecordId AUTOGENERATED = new RecordId(GENERATE_ID) {
        @Override
        public Long getSequence() {
            return null;
        }

        @Override
        public Long getTimestamp() {
            return null;
        }

        @Override
        public boolean shouldBeAutoGenerated() {
            return true;
        }
    };

    private final String raw;

    /**
     * 私有构造函数 - 验证静态初始化块中的输入
     */
    private RecordId(String raw) {
        this.raw = raw;
    }

    /**
     * 使用格式为 {@literal <millisecondsTime>-<sequenceNumber>} 的提供的字符串获取 {@link RecordId} 的实例。 <br />
     * 对于服务器在插入时自动生成的 {@literal entry-id}，传入 {@literal null} 或 {@literal }。事件更好，只需使用 {@link #autoGenerate()}
     *
     * @param value 可以是 {@literal null}
     * @return {@link RecordId} 的新实例，如果没有自动生成请求的话
     */
    public static RecordId of(String value) {
        if (value == null || GENERATE_ID.equals(value)) {
            return autoGenerate();
        }
        Assert.isTrue(value.contains(DELIMITER), "Invalid id format. Please use the 'millisecondsTime-sequenceNumber' format.");
        return new RecordId(value);
    }

    /**
     * 使用格式为 {@literal <millisecondsTime>-<sequenceNumber>} 的字符串创建 {@link RecordId} 的新实例。<br />
     * 对于服务器在插入时自动生成的 {@literal entry-id} 使用 {@link #autoGenerate()}
     *
     * @return {@link RecordId} 的新实例
     */
    public static RecordId of(long millisecondsTime, long sequenceNumber) {
        return of(millisecondsTime + DELIMITER + sequenceNumber);
    }

    /**
     * 获取 {@link RecordId} 通知服务器在插入时自动生成 {@literal entry-id} ({@code XADD})
     *
     * @return {@link RecordId} 实例信号 {@link #shouldBeAutoGenerated()}
     */
    public static RecordId autoGenerate() {
        return AUTOGENERATED;
    }

    /**
     * 获取 {@literal entry-id millisecondsTime} 部分或 {@literal null} 如果它是 {@link #shouldBeAutoGenerated()}
     *
     * @return {@literal entry-id} 的毫秒时间。可以是 {@literal null}
     */
    public Long getTimestamp() {
        return value(0);
    }

    /**
     * 获取 {@literal entry-id sequenceNumber} 部分或 {@literal null} 如果它是 {@link #shouldBeAutoGenerated()}
     *
     * @return {@literal entry-id} 的序列号。可以是 {@literal null}
     */
    public Long getSequence() {
        return value(1);
    }

    /**
     * @return {@literal true} 如果在调用 {@code XADD} 时应在服务器端生成新的 {@literal entry-id}
     */
    public boolean shouldBeAutoGenerated() {
        return false;
    }

    /**
     * @return 以 {@literal <millisecondsTime>-<sequenceNumber>} 格式获取 {@literal entry-id} 的字符串表示形式，
     * 如果是 {@link #shouldBeAutoGenerated()}，则获取 {@literal *} 的字符串表示形式。
     * 从不为 {@literal null}
     */
    public String getValue() {
        return raw;
    }

    @Override
    public String toString() {
        return raw;
    }

    private Long value(int index) {
        return NumberUtils.parseNumber(Objects.requireNonNull(StringUtils.split(raw, DELIMITER))[index], Long.class);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        RecordId recordId = (RecordId) o;
        return ObjectUtils.nullSafeEquals(raw, recordId.raw);
    }

    @Override
    public int hashCode() {
        return ObjectUtils.nullSafeHashCode(raw);
    }
}
